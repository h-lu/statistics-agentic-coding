# 写作范例库（供 Agent 参照）

本文件给出"教材写作"的具体 before / after 范例。
所有写章节的 agent 在动笔前必须读此文件，理解"好"与"坏"的区别。

---

## 原则速览

1. **叙事优先，结论收尾**——先带读者经历一个场景/困惑，再给出概念名称。不要上来就"本节介绍 X"。
2. **贯穿案例**——每章围绕一个渐进式小项目展开，每学一个概念就往项目上加一层。读者在章末能拿到一个"有用的小东西"。
3. **变化的节奏**——长句解释、短句点睛；段落叙述与代码块穿插；偶尔反问、偶尔设悬念。不要每节结构都一模一样。
4. **真实的温度**——像一个有经验的老师坐在学生旁边讲，不是一个委员会写的规范文档。

---

## 范例 1：引入新概念

### ❌ 坏（模板填空式）

> ## 2. 变量与赋值
>
> 程序需要"记住"数据。比如计算一个人的 BMI，你需要记住身高和体重，然后才能计算。
>
> 变量的作用就是给数据"贴标签"。想象你有两个盒子，一个贴"身高"，一个贴"体重"——变量名就是那个标签。
>
> ### 2.1 最小正例
>
> ```python
> name = "Alice"
> age = 20
> print(name, "今年", age, "岁")
> ```
>
> 输出：
>
> ```
> Alice 今年 20 岁
> ```

**问题在哪？**
- 一句话概念 → 一个比喻 → 直接跳代码。太快了，没有让读者"感受到需要"。
- "最小正例"这种小标题本身就暴露了模板感。
- 比喻（"贴标签"）过于老套，每个 AI 都会生成这个比喻。

### ✅ 好（场景驱动式）

> ## 2. 让程序记住东西
>
> 上一节我们让 Python 说了"Hello, World!"——但你发现没有？那个程序是"一次性"的。它说完就忘了，下一行代码根本不知道上一行发生了什么。
>
> 现在试一个稍微有意思的事情：你想让程序先问用户叫什么名字，然后跟他打招呼。问题来了——`input()` 拿到名字之后，怎么"记住"它，留到 `print()` 的时候再用？
>
> 答案是**变量**（variable）：
>
> ```python
> name = input("你叫什么名字？")
> print("你好，" + name + "！")
> ```
>
> `name` 就是一个变量。你可以把它想成一个写着名字的便利贴：`input()` 把用户敲进去的文字写在这张便利贴上，后面的代码随时可以去看。
>
> `=` 在这里不是数学的"等于"，而是"把右边的东西存到左边的名字里"。这个动作叫**赋值**（assignment）。第一次见到会觉得别扭，但写几次就习惯了。

**为什么好？**
- 从上一节的成果自然过渡，读者感受到"我确实需要这个新东西"。
- 概念是在解决问题的过程中引出的，不是先定义再举例。
- 比喻（便利贴）出现在代码之后，是辅助理解而非开场白。
- 承认"第一次会觉得别扭"——有温度，像真人在说话。

---

## 范例 2：讲解常见错误

### ❌ 坏（清单罗列式）

> ### 2.3 常见错误
>
> **使用未定义的变量**：
>
> ```python
> print(score)
> ```
>
> 报错：`NameError: name 'score' is not defined`
>
> 原因：使用变量前必须先赋值。Python 找不到名为 `score` 的标签。
>
> **大小写不匹配**：
>
> ```python
> name = "Bob"
> print(Name)
> ```
>
> 报错：`NameError: name 'Name' is not defined`
>
> 原因：定义的是小写的 `name`，使用时却写了大写的 `Name`。

**问题在哪？**
- 像 bug 数据库的工单列表，不像教材。
- 没有任何"学生真的会在什么情况下犯这个错"的铺垫。
- 读者感觉在被警告，而不是在学东西。

### ✅ 好（情境还原式）

> 写完上面那段代码运行一下。如果顺利，你会看到正确的输出。
>
> 但很可能不顺利——初学者（甚至老手）最常碰到的一个意外是这样的：
>
> ```python
> name = "小明"
> print(Name)   # 注意这里的大写 N
> ```
>
> 运行后 Python 会报错：
>
> ```
> NameError: name 'Name' is not defined
> ```
>
> 你定义的是 `name`（小写），但用的是 `Name`（大写）。在 Python 的世界里，这是两个完全不同的名字——就像"张伟"和"张威"在户口本上是两个人。Python 不会猜你"大概是想说那个 name 吧"，它会直接告诉你"我不认识 Name"。
>
> 所以养成一个习惯：**变量名全部用小写字母加下划线**（比如 `user_name`），这样永远不会在大小写上翻车。

**为什么好？**
- 错误是在"学生正在写代码"的语境中出现的，不是突然跳出来的清单。
- 报错信息之后有"拟人化"的解释（"Python 不会猜"），帮助读者建立直觉。
- 收尾给了一个可执行的习惯建议，不只是说"注意大小写"。

---

## 范例 3：章节开头（引入动机）

### ❌ 坏

> ## 3. 输入与输出
>
> 程序如果只是自己运行、自己输出，那就和计算器没区别。真正的程序需要**与用户交互**——询问信息，然后给出回应。

**问题在哪？**
- "和计算器没区别"是一个正确但无感的陈述。读者不会因为这句话而好奇。
- 两句话就把动机讲完了，太仓促。

### ✅ 好

> ## 3. 跟用户聊起来
>
> 到目前为止，我们的程序都是"自说自话"：你写好代码，它输出固定的结果，每次运行都一模一样。这有点无聊——你肯定见过那些会问你问题的程序，比如注册账号时让你输入用户名、密码。
>
> 那 Python 怎么做到"等用户输入"这件事呢？

**为什么好？**
- 先让读者意识到"现在的程序确实无聊"。
- 用读者真实见过的场景（注册账号）唤起经验。
- 最后一句是问句，制造了一个小悬念，读者想继续读下去。

---

## 范例 4：小结的写法

### ❌ 坏（项目符号堆砌）

> ### 3.4 小结
>
> - `input()` 获取用户输入，返回字符串
> - 数字运算前需要用 `int()` 转换成整数
> - 如果输入的内容无法转换，会报 ValueError

### ✅ 好（回顾 + 展望）

> 这一节你学会了让程序"等人说话"。`input()` 拿到的东西永远是文字（字符串），如果你要拿它做数学运算，得先用 `int()` 告诉 Python"这其实是个数字"。
>
> 到这里，你已经掌握了输出（`print`）、记忆（变量）和输入（`input`）。下一节我们来聊聊文字本身——Python 里的字符串比你想的能干得多。

**为什么好？**
- 用叙述而非列表，读起来是"一段话"而不是"三条规则"。
- 把本节放在全章脉络里（"你已经掌握了……"），帮读者建立进度感。
- 自然引出下一节，读者有继续读的欲望。

---

## 范例 5：贯穿案例的用法

一章围绕一个渐进式小项目展开。week_01 的贯穿案例可以是**"个人名片生成器"**：

- 第 1 节（print）：先硬编码输出一张固定名片
- 第 2 节（变量）：把姓名、年龄存进变量，名片变得"可配置"
- 第 3 节（input）：让用户自己输入信息，名片变成"交互式"
- 第 4 节（字符串）：用 f-string 美化名片格式
- 第 5 节（错误）：故意触发各种错误，学会读报错信息

每节末尾都能运行，看到"名片"在一步步变好——读者有成就感。

---

## 范例 6：循环角色的使用

### ❌ 坏（为出场而出场）

> 小北说："变量就是用来存数据的。"
>
> 阿码说："对，我也是这么理解的。"

**问题在哪？**
- 角色在复述正文已经说过的内容，没有增加任何价值。
- 小北不应该"解释概念"——他是零基础学生，应该犯错和提问。
- 阿码只是附和，没有展示他"好奇心强、爱追问"的性格。

### ✅ 好（角色推动叙事）

> 小北照着教材敲完代码，自信满满地按下回车——然后 Python 用红色大字教育了他：
>
> ```
> NameError: name 'Name' is not defined
> ```
>
> "等等，我明明定义了 `name` 啊？"小北盯着屏幕，反复检查了三遍。
>
> 你发现问题了吗？`name` 和 `Name` 在 Python 看来是两个完全不同的名字。
>
> 阿码在旁边探头看了一眼："那如果我故意用大写字母当变量名呢？比如 `Name = '阿码'`——这样合法吗？"
>
> 好问题——合法，但不推荐。Python 社区有个约定：普通变量全部用小写加下划线。

**为什么好？**
- 小北通过犯错引出了大小写问题，比直接说"注意大小写"更有记忆点。
- 阿码追问了一个边界情况（大写变量名是否合法），读者可能也想问这个。
- 角色互动让"枯燥的命名规范"变成了一段有画面感的场景。

---

## 范例 7：回顾桥的写法

### ❌ 坏（生硬复习）

> ## 回顾
>
> 上周我们学习了 `for` 循环。`for` 循环的语法是：
>
> ```python
> for i in range(n):
>     print(i)
> ```
>
> 本周我们将学习列表。

**问题在哪？**
- 这是"复习课"，不是"回顾桥"——在重复上周的内容，没有连接到本周。
- 读者会觉得"这我已经知道了"，跳过不看。
- "本周我们将学习"是禁忌开头。

### ✅ 好（在新场景中让旧概念再次出场）

> 上周你用 `for` 循环从 1 数到 10——但数到的都是数字。
>
> 这周你手里有一份班级名单，五个人的名字。你想一个一个打印出来——怎么办？
>
> 还是 `for`，但这次遍历的不是 `range()`，而是一个**列表**（list）：
>
> ```python
> names = ["小北", "阿码", "老潘", "小红", "小明"]
> for name in names:
>     print(f"到！{name}")
> ```
>
> 同样的 `for`，不同的数据源。这就是列表的威力——它给了你一个"装东西的容器"。

**为什么好？**
- 从上周的成果（`for` + `range`）自然过渡到本周的新概念（列表）。
- 读者感受到"原来 `for` 还能这样用"——旧知识在新场景下焕发新意。
- 用循环角色的名字做列表数据，增加代入感。

---

## 范例 8：PyHelper 超级线进度写法

### ❌ 坏（与正文脱节）

> ## PyHelper 进度
>
> 本周给 PyHelper 加了异常处理。代码如下：
>
> ```python
> try:
>     choice = int(input("请选择："))
> except ValueError:
>     print("请输入数字")
> ```

**问题在哪？**
- 代码直接出现，没有叙事上下文。
- 没有说明"为什么 PyHelper 需要这个改进"。
- 没有与本周正文内容建立连接。

### ✅ 好（自然融入本周主题）

> ## PyHelper 进度
>
> 到目前为止，PyHelper 有一个致命弱点：如果你在菜单选择时输入了"abc"而不是数字——它直接崩溃。
>
> 这正好是本周学的内容派上用场的地方。给 PyHelper 穿上"防弹衣"：
>
> ```python
> def get_choice():
>     while True:
>         try:
>             choice = int(input("请选择 (1-4)："))
>             if 1 <= choice <= 4:
>                 return choice
>             print("请输入 1 到 4 之间的数字。")
>         except ValueError:
>             print("这不是数字，再试一次。")
> ```
>
> 现在无论用户输入什么乱七八糟的东西，PyHelper 都不会崩了——它会耐心地等你输入正确的选项。
>
> 老潘看到这段代码会说什么？"这就对了。用户永远会做你想不到的事情。"

**为什么好？**
- 从 PyHelper 的真实"痛点"出发，让本周知识（异常处理）有了用武之地。
- 改进有前后对比（之前会崩，现在不会）。
- 用老潘的点评收束，增加工程视角。

---

## 禁忌清单

| 编号 | 禁忌 | 替代 |
|------|------|------|
| 1 | 每节用相同的子标题模式（"最小正例""常见错误""小结"） | 让内容决定结构，每节可以不同 |
| 2 | 用"在本节中，我们将…"开头 | 用场景/问题/悬念开头 |
| 3 | 列表超过 5 条连续出现 | 拆散到段落叙述中 |
| 4 | "编程本质上是…"类的空泛定义 | 用具体场景替代 |
| 5 | 一节内只有代码块 + 一句话解释 | 代码前后都要有足够的叙述上下文 |
| 6 | 用"重要心态""注意"等说教标签 | 把态度建议织进叙述里 |
| 7 | 每节末尾都用项目符号列表做小结 | 可以用叙述段落、可以用表格、可以用回顾问句 |
