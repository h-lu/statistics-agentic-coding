# Week 05 作业：概率与模拟——从"算数"到"量化不确定性"

> "Probability is the very guide of life."
> — Cicero

本周作业要求你用模拟方法建立概率直觉，理解抽样分布，并用 Bootstrap 量化统计结论的不确定性。

---

## 作业结构

| 层级 | 内容 | 建议时间 |
|------|------|----------|
| 基础作业（必做） | 贝叶斯定理计算、分布识别、CLT 模拟、Bootstrap 分析 | 3-4 小时 |
| 进阶作业（选做） | 比较统计量稳定性、敏感性分析 | 1-2 小时 |
| 挑战作业（选做） | 设计概率直觉实验 | 1-2 小时 |
| AI 协作练习（可选） | 审查 AI 生成的统计结论 | 1 小时 |

---

## 基础作业（必做）

### 任务 1：贝叶斯定理的实际应用（25 分）

**目标**：用贝叶斯定理解决一个反直觉的概率问题，理解先验对后验的影响。

**场景**：某罕见病的发病率为 0.1%（千分之一），现有一种检测方法，敏感性为 99%（真阳性率），特异性为 95%（真阴性率）。

**步骤**：

1. **手工计算**
   - 计算检测阳性的总概率 P(阳性)
   - 计算阳性后真正患病的概率 P(患病|阳性)
   - 解释为什么这个数字远低于检测准确率

2. **编程验证**
   - 写函数 `bayes_theorem(prevalence, sensitivity, specificity)` 返回后验概率
   - 用模拟验证：生成 100,000 人，模拟检测过程，统计 P(患病|阳性)
   - 比较理论值和模拟值

3. **先验影响分析**
   - 将发病率改为 0.01%、0.1%、1%、10%，分别计算 P(患病|阳性)
   - 绘制先验 vs 后验的折线图
   - 解释：为什么先验对罕见病筛查如此重要

**预期输出**：

```text
=== 贝叶斯定理分析报告 ===

参数：
- 发病率 P(患病) = 0.1%
- 敏感性 P(阳性|患病) = 99%
- 特异性 P(阴性|健康) = 95%

手工计算：
- P(阳性) = P(阳性|患病)×P(患病) + P(阳性|健康)×P(健康)
- P(阳性) = 0.99×0.001 + 0.05×0.999 = 0.05094
- P(患病|阳性) = 0.99×0.001 / 0.05094 ≈ 1.94%

模拟验证（100,000 人）：
- 真实患病：100 人
- 检测阳性：5,094 人
- 真阳性：99 人
- 假阳性：4,995 人
- P(患病|阳性) 模拟值 = 1.94%

结论：即使检测准确率看似很高（敏感性 99%），阳性后真正患病的概率不到 2%。
这是因为在健康人群基数大时，假阳性会淹没真阳性。
```

**常见错误**：
- 混淆 P(患病|阳性) 和 P(阳性|患病)
- 忘记计算 P(阳性) 的分母（直接用分子当答案）
- 忽略先验概率的影响

---

### 任务 2：分布识别与参数估计（25 分）

**目标**：识别数据符合哪种概率分布，估计分布参数，判断极端事件概率。

**数据**：使用你的 StatLab 数据集，或以下任一场景：
- 用户点击率（0/1 数据，适合二项分布）
- 每小时客服接到的投诉数（计数数据，适合泊松分布）
- 用户消费金额（连续数据，可能正态或偏态）

**步骤**：

1. **可视化分布**
   - 绘制直方图和密度曲线
   - 计算描述统计：均值、方差、偏度、峰度

2. **分布识别**
   - 根据数据类型和形状判断可能的分布类型
   - 计算理论分布的参数（如正态的 μ、σ，泊松的 λ）
   - 叠加理论分布图，观察拟合程度

3. **极端事件预测**
   - 计算"超过某个阈值"的概率（如消费 > 5000 元）
   - 用理论分布计算，并用模拟验证

**预期输出**：

```text
=== 分布识别报告 ===

数据概览：
- 变量：用户消费金额
- 样本量：500
- 均值：1,250 元
- 标准差：850 元
- 偏度：2.1（右偏）
- 峰度：5.8（尖峰）

分布识别：
- 数据类型：连续、非负
- 形状：严重右偏
- 建议分布：对数正态分布 或 威布尔分布
- 结论：不适合使用正态分布假设

参数估计（对数正态）：
- log(μ) = 6.8
- log(σ) = 0.6
- 原始均值：exp(6.8 + 0.6²/2) ≈ 1,250

极端事件预测：
- P(消费 > 5000) ≈ 3.2%
- P(消费 > 10000) ≈ 0.4%
- 模拟验证：10000 次模拟中，消费 > 5000 出现 318 次
```

**常见错误**：
- 不检查数据形状直接假设正态分布
- 忽略偏度和峰度
- 泊松分布使用时忘记检查 E[X] ≈ Var(X)

---

### 任务 3：中心极限定理模拟实验（25 分）

**目标**：用模拟验证 CLT，观察样本量对均值分布的影响。

**步骤**：

1. **选择总体**
   - 生成一个严重偏态的总体（如指数分布、对数正态分布）
   - 计算总体的均值、标准差、偏度

2. **CLT 模拟**
   - 对样本量 n = 5, 10, 30, 100 分别：
     - 重复抽样 10,000 次
     - 计算每次的样本均值
     - 绘制样本均值的分布直方图
     - 叠加理论正态分布曲线

3. **正态性检验**
   - 对每个样本量的均值分布进行 Shapiro-Wilk 正态性检验
   - 记录 p 值，判断是否拒绝正态假设

4. **标准误验证**
   - 计算每个样本量下的实际标准误（样本均值分布的标准差）
   - 与理论标准误 SE = σ/√n 比较

**预期输出**：

```text
=== CLT 模拟实验报告 ===

总体分布：
- 类型：指数分布（严重右偏）
- 均值 μ = 10.0
- 标准差 σ = 10.0
- 偏度 = 2.0

样本均值分布统计：

| 样本量 n | 均值分布均值 | 标准误（实际） | 标准误（理论） | 正态性 p 值 | 是否正态？ |
|----------|--------------|----------------|----------------|-------------|-----------|
| 5        | 10.02        | 4.52           | 4.47           | < 0.001    | 否        |
| 10       | 9.99         | 3.21           | 3.16           | 0.002       | 否        |
| 30       | 10.01        | 1.83           | 1.83           | 0.12        | 是（勉强）|
| 100      | 10.00        | 1.00           | 1.00           | 0.58        | 是        |

关键发现：
1. 样本量越大，样本均值分布越接近正态
2. 实际 SE 与理论 SE 高度一致
3. n=30 时，均值分布仍略微偏离正态（因为总体严重偏态）
4. n=100 时，CLT 效果明显
```

**常见错误**：
- 使用正态总体，看不到 CLT 的效果（因为本来就是正态）
- 样本量不够大（如 n<5），无法观察渐进效果
- 忘记设置随机种子，结果不可复现

---

### 任务 4：Bootstrap 置信区间（25 分）

**目标**：用 Bootstrap 估计关键统计量的置信区间，量化不确定性。

**数据**：你的 StatLab 数据集

**步骤**：

1. **Bootstrap 均值**
   - 选择一个关键变量（如消费金额）
   - 进行 10,000 次 Bootstrap 重采样
   - 计算均值的 95% 置信区间（percentile 方法）
   - 记录标准误

2. **Bootstrap 两组均值差异**
   - 选择两组对比（如钻石用户 vs 普通用户）
   - Bootstrap 均值差异的分布
   - 计算 95% CI，判断是否包含 0

3. **Bootstrap 相关系数**
   - 选择两个相关变量（如收入 vs 消费）
   - Bootstrap 相关系数（注意：成对重采样）
   - 计算 95% CI，判断是否包含 0

**预期输出**：

```text
=== Bootstrap 不确定性量化报告 ===

1. 单变量 Bootstrap（消费金额均值）
- 点估计：1,250 元
- 95% CI：[1,150, 1,360] 元
- 标准误：53 元
- 解读：我们有 95% 的信心认为真实均值在 1,150 到 1,360 元之间

2. 两组差异 Bootstrap（钻石 vs 普通）
- 点估计：3,350 元
- 95% CI：[2,980, 3,720] 元
- 标准误：190 元
- CI 包含 0？否 → 差异在统计上显著

3. 相关性 Bootstrap（收入 vs 消费）
- 点估计：r = 0.52
- 95% CI：[0.38, 0.64]
- 标准误：0.067
- CI 包含 0？否 → 相关性在统计上显著
```

**常见错误**：
- Bootstrap 时忘记 `replace=True`
- 相关系数 Bootstrap 时没有成对重采样（破坏了配对关系）
- 混淆标准差和标准误

---

## 进阶作业（选做）

### 任务 5：比较不同统计量的稳定性（+10 分）

**目标**：比较均值、中位数、 trimmed 均值的 Bootstrap 分布。

**步骤**：

1. 对同一组数据进行 Bootstrap，分别估计：
   - 均值的抽样分布
   - 中位数的抽样分布
   - 10% trimmed 均值的抽样分布

2. 比较：
   - 三者的标准误（哪个最稳定？）
   - 三者的置信区间宽度
   - 当数据存在极端值时，哪个更稳健？

---

### 任务 6：敏感性分析（+10 分）

**目标**：测试 Bootstrap 结论的稳健性。

**步骤**：

1. **改变 Bootstrap 次数**
   - 比较 n_bootstrap = 100, 1,000, 10,000 的 CI 差异
   - 结论：多少次足够稳定？

2. **剔除极端值后重做**
   - 剔除前 5% 极端值
   - 重新 Bootstrap，比较 CI 变化

3. **改变置信水平**
   - 计算 80%, 90%, 95%, 99% CI
   - 观察 CI 宽度与置信水平的关系

---

## 挑战作业（选做）

### 任务 7：设计一个概率直觉实验（+15 分）

**目标**：设计一个能帮助建立概率直觉的模拟实验。

**要求**：

1. 选择一个反直觉的概率问题（可以是经典的，也可以是你自己发现的）
2. 设计模拟实验来验证直觉
3. 写清晰的代码和注释
4. 输出可解释的图表和数字

**可选主题**：

- 蒙提霍尔问题（三门问题）
- 生日悖论（23 人中有 50% 概率有人同生日）
- 赌徒谬误（连续 10 次正面后，第 11 次还是正面？）
- 幸存者偏差（为什么二战返航飞机的弹痕统计有偏差？）

---

## AI 协作练习（可选）

### 练习 1：审查 AI 生成的统计结论

下面这段代码是某个 AI 工具生成的"统计摘要"：

```python
import numpy as np
import pandas as pd

def quick_stat_summary(df, col1, col2):
    """AI 生成的快速统计摘要"""
    results = {}

    # 1. 计算均值和标准差
    results['mean1'] = df[col1].mean()
    results['std1'] = df[col1].std()
    results['mean2'] = df[col2].mean()
    results['std2'] = df[col2].std()

    # 2. 计算相关系数
    results['correlation'] = df[col1].corr(df[col2])

    # 3. 判断相关性强度
    if abs(results['correlation']) > 0.7:
        results['interpretation'] = '强相关'
    elif abs(results['correlation']) > 0.3:
        results['interpretation'] = '中等相关'
    else:
        results['interpretation'] = '弱相关'

    # 4. 两组均值差异
    group1 = df[df['group'] == 'A'][col1]
    group2 = df[df['group'] == 'B'][col1]
    results['mean_diff'] = group1.mean() - group2.mean()

    # 5. 标准误（这里可能有错误！）
    results['se'] = results['std1']  # 错误！应该是 SD / sqrt(n)

    return results
```

**请审查这段代码**：

- [ ] 代码能运行吗？有没有潜在的 bug？
- [ ] 变量命名清晰吗？
- [ ] "标准误"的计算正确吗？如果不正确，应该怎么改？
- [ ] 相关系数的解读有没有问题？（如没有区分 Pearson/Spearman）
- [ ] 有没有缺少错误处理？（如列不存在、空分组）
- [ ] 你能写一个让它失败的测试用例吗？

**提交**：修复后的代码 + 你发现的问题清单（300 字以内）。

---

### 练习 2：用 AI 辅助编写模拟代码

让 AI 帮你生成一个"验证贝叶斯定理"的模拟代码，然后：

1. **验证正确性**
   - AI 的计算公式对吗？
   - 模拟设计合理吗？
   - 随机种子设置了吗？

2. **改进代码**
   - AI 的代码风格统一吗？
   - 注释清晰吗？
   - 能复现吗？

3. **文档输出**
   - 运行代码，生成解释性图表
   - 把结果写成可读的分析报告

**提交**：AI 生成的原始代码 + 你改进后的代码 + 对比说明。

---

## StatLab 作业

在 `report.md` 中添加"不确定性量化"章节。

### 必须包含的内容

1. **核心统计量汇总表**
   - 均值、均值差异、相关系数
   - 每个统计量的点估计、95% CI、标准误

2. **关键发现**
   - 哪些结论显著（CI 不包含 0）？
   - 哪些估计稳定（SE 小）？
   - 哪些发现需要更多数据支持？

3. **敏感性分析**
   - 剔除极端值前后变化
   - Bootstrap 次数稳定性
   - 不同统计量对比

4. **数据局限**
   - Bootstrap 假设
   - 未控制的混杂
   - 因果解释的限制

### 格式参考

```markdown
## 不确定性量化

> 本章说明关键统计量的波动范围，为后续假设检验提供基础。
> 生成时间：2026-02-12

### 核心统计量的稳定性

| 统计量 | 点估计 | 95% CI (Bootstrap) | 标准误 | 解读 |
|--------|--------|---------------------|---------|------|
| 钻石用户平均消费 | 4,200 元 | [3,800, 4,650] | 210 元 | 区间较窄，估计稳定 |
| 普通用户平均消费 | 850 元 | [780, 920] | 85 元 | 样本量大，波动小 |
| 均值差异 | 3,350 元 | [2,980, 3,720] | 190 元 | **不包含 0，预期显著** |
| 收入-消费相关系数 | 0.52 | [0.38, 0.64] | 0.067 | 中度正相关，稳定 |

### 关键发现

1. **均值差异稳定**：Bootstrap 95% CI 不包含 0，说明钻石用户与普通用户的消费差异在统计上显著
2. **相关性稳健**：Pearson 和 Spearman 相关系数一致，异常值影响有限
3. **样本量充足**：当前样本量下，标准误已控制在可接受范围

### 敏感性分析

- **剔除前 5% 极端值**：均值差异变化 < 8%，结论稳健
- **改变 Bootstrap 次数（1000 vs 10000）**：CI 边界变化 < 2%，收敛稳定
- **使用中位数代替均值**：钻石用户中位数仍是普通用户的 4.2 倍

### 数据局限

- **Bootstrap 假设样本代表性**：如果样本存在系统性偏差，置信区间无法修正
- **未控制混杂变量**：收入、年龄、城市级别可能混杂等级-消费关系
- **横截面数据**：无法确定因果方向
```

---

## 提交要求

### 文件列表

```
week_05/
├── data/
│   └── (你的数据文件)
├── scripts/
│   ├── 01_bayes_theorem.py      # 任务 1
│   ├── 02_distribution_fit.py    # 任务 2
│   ├── 03_clt_simulation.py      # 任务 3
│   └── 04_bootstrap_analysis.py  # 任务 4
├── report.md                      # 包含不确定性量化章节
├── figures/                       # 生成的图表
└── README.md                      # 运行说明
```

### Git 提交

至少 3 次 commit，建议：

```bash
# 第一次：贝叶斯定理和分布识别
git add scripts/01_bayes_theorem.py scripts/02_distribution_fit.py
git commit -m "feat: implement Bayes theorem calculation and distribution fitting"

# 第二次：CLT 模拟
git add scripts/03_clt_simulation.py
git commit -m "feat: add CLT simulation with multiple sample sizes"

# 第三次：Bootstrap 分析和报告
git add scripts/04_bootstrap_analysis.py report.md figures/
git commit -m "feat: add bootstrap uncertainty analysis and update report"
```

### 提交内容

1. 所有脚本文件（可运行）
2. 包含不确定性量化章节的 report.md
3. README.md（说明如何运行脚本）
4. 生成的图表文件

---

## 提示与资源

### 关键代码片段

**贝叶斯定理**：
```python
def bayes_theorem(prevalence, sensitivity, specificity):
    """计算 P(患病|阳性)"""
    p_positive_given_sick = sensitivity
    p_positive_given_healthy = 1 - specificity
    p_sick = prevalence
    p_healthy = 1 - prevalence

    p_positive = (p_positive_given_sick * p_sick +
                  p_positive_given_healthy * p_healthy)

    p_sick_given_positive = (p_positive_given_sick * p_sick) / p_positive
    return p_sick_given_positive
```

**Bootstrap 均值**：
```python
def bootstrap_mean(sample, n_bootstrap=10000, seed=42):
    rng = np.random.default_rng(seed)
    n = len(sample)
    boot_means = np.array([
        np.mean(rng.choice(sample, size=n, replace=True))
        for _ in range(n_bootstrap)
    ])
    ci_low = np.percentile(boot_means, 2.5)
    ci_high = np.percentile(boot_means, 97.5)
    se = boot_means.std(ddof=1)
    return {
        'observed': np.mean(sample),
        'ci_low': ci_low,
        'ci_high': ci_high,
        'se': se
    }
```

**CLT 模拟**：
```python
def clt_simulation(population, sample_size, n_simulations=10000, seed=42):
    rng = np.random.default_rng(seed)
    sample_means = np.array([
        np.mean(rng.choice(population, sample_size, replace=False))
        for _ in range(n_simulations)
    ])
    return sample_means
```

### 遇到困难？

- 参考 `examples/` 目录下的示例代码
- 回顾 CHAPTER.md 中的代码示例和角色对话
- 在讨论区提问，附上你的代码和具体错误

---

**截止日期**：本周日 23:59
